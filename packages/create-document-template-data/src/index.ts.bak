import { DataSource, DataSourceOptions } from 'typeorm';
import { jsonToMarkdown } from './json-to-md.js';
import {
  GitHubContributorIssuePrEntity,
  GitHubContributorEntity,
  GitHubRepositoryEntity,
  GitHubWorkflowEntity,
} from '@dfb/db';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
/**
 * Utility to get all entity (table) names in the database.
 * Returns an array of objects with entity name and class.
 */
export function getAllEntities() {
  return [
    { name: 'contributor_issues_prs', entity: GitHubContributorIssuePrEntity },
    { name: 'contributors', entity: GitHubContributorEntity },
    { name: 'repositories', entity: GitHubRepositoryEntity },
    { name: 'workflows', entity: GitHubWorkflowEntity },
  ];
}

/**
 * Generates a timestamp string in YYYYMMDDHHMMSS format.
 */
function getTimestamp(): string {
  const now = new Date();
  const pad = (n: number) => n.toString().padStart(2, '0');
  return (
    now.getFullYear().toString() +
    pad(now.getMonth() + 1) +
    pad(now.getDate()) +
    pad(now.getHours()) +
    pad(now.getMinutes()) +
    pad(now.getSeconds())
  );
}

/**
 * Constructs the category string for a row based on the table/entity name and row data.
 */
function constructCategory(
  tableName: string,
  row: Record<string, any>
): string | null | undefined {
  try {
    switch (tableName) {
      case 'contributor_issues_prs':
        if (
          row.org &&
          row.repo &&
          row.username &&
          row.type &&
          row.id !== undefined
        ) {
          return `${row.type.toString().toUpperCase()}:${row.org}/${row.repo}:${row.username}:${row.id}`;
        }
        break;
      case 'contributors':
        if (row.id !== undefined) {
          return `CONTRIBUTOR:${row.id}`;
        }
        break;
      case 'repositories':
        if (row.nameWithOwner && row.id !== undefined) {
          return `REPOSITORY:${row.nameWithOwner}:${row.id}`;
        }
        break;
      case 'workflows':
        if (row.orgRepo && row.id !== undefined && row.path) {
          return `WORKFLOW:${row.orgRepo}/${row.id}:${row.path}`;
        }
        break;
      default:
        return;
    }
  } catch (err) {
    // Defensive: should not throw, but just in case
    return null;
  }
  return null;
}

/**
 * Creates a new document_templates_{timestamp} table and processes all entities,
 * inserting a row for each valid source row.
 */
export async function createDocumentTemplateData(dbPath: string) {
  // Create DataSourceOptions (adjust as needed for your environment)
  const options: DataSourceOptions = {
    type: 'sqlite',
    database: dbPath,
    entities: [
      GitHubContributorIssuePrEntity,
      GitHubContributorEntity,
      GitHubRepositoryEntity,
      GitHubWorkflowEntity,
    ],
  };
  const dataSource = new DataSource(options);
  await dataSource.initialize();

  const timestamp = getTimestamp();
  const tableName = `document_templates_${timestamp}`;

  // Create the new table with raw SQL
  await dataSource.query(`
    CREATE TABLE IF NOT EXISTS ${tableName} (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      category TEXT NOT NULL,
      text TEXT NOT NULL,
      date_created TEXT NOT NULL
    )
  `);

  const entities = getAllEntities();
  let insertedCount = 0;
  let skippedCount = 0;

  for (const { name, entity } of entities) {
    try {
      const rows = await dataSource.getRepository(entity).find();

      console.log(`Processing table: ${name}, rows: ${rows.length}`);

      for (const row of rows) {
        const category = constructCategory(name, row);
        console.log(`${category}`);
        if (!category) {
          console.log(
            `[SKIP] Could not construct category for table ${name}, row:`,
            row
          );
          skippedCount++;
          continue;
        }
        let text: string;
        try {
          text = jsonToMarkdown(row);
        } catch (err) {
          console.log(
            `[SKIP] Error converting row to markdown for table ${name}, row:`,
            row,
            'Error:',
            err
          );
          skippedCount++;
          continue;
        }
        const date_created = new Date().toISOString();
        await dataSource.query(
          `INSERT INTO ${tableName} (category, text, date_created) VALUES (?, ?, ?)`,
          [category, text, date_created]
        );
        insertedCount++;
      }
    } catch (err) {
      console.log(`[SKIP] Error processing table ${name}:`, err);
    }
  }

  console.log(
    `Finished processing. Inserted: ${insertedCount}, Skipped: ${skippedCount}, Table: ${tableName}`
  );

  await dataSource.destroy();
  return { tableName, insertedCount, skippedCount };
}

// Run the real data creation when this script is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const dbPath = './data/github.db';
  createDocumentTemplateData(dbPath)
    .then(() => console.log('Data creation completed.'))
    .catch(err => console.error('Data creation failed:', err));
}
